# Shell 变量

- 定义变量时，变量名不加美元符号 `$` —— e.g. `MY_ENV="my env"`；变量名和等号之间不能有空格，同时，变量名的命名须遵循以下规则：
  1. 命名只能使用英文字母、数字和下划线，首个字符不能以数字开头。
  2. 中间不能有空格，可以使用下划线 `_`。
  3. 不能使用标点符号。
  4. 不能使用 `bash` 里的关键字（可用 `help` 命令查看保留关键字）。
- 使用变量 `echo $MY_ENV` 或 `${MY_ENV}`
- 只读变量 `readonly MY_ENV`
- 删除变量 `unset MY_ENV`

### **变量类型**
1. **本地变量**：用户自定义的变量。
2. **环境变量**：用于所有用户变量，用于用户进程前，必须用 `export` 命令导出。
3. **位置变量**：`$0`（脚本名），`$1-$9`：脚本参数。
4. **特定变量**：脚本运行时的一些相关信息。

### **特定变量详情**

| **变量** | **描述**                                                       |
| -------- | -------------------------------------------------------------- |
| `$#`     | 传递到脚本的参数个数                                           |
| `$$`     | 脚本运行时当前进程的 ID 号，常用作临时变量的后缀，如 `root.$$` |
| `$!`     | 后台运行的（`&`）最后一个进程的 ID 号                          |
| `$_`     | 上一个命令的最后一个参数                                       |
| `$?`     | 最后命令的退出状态，`0` 表示没有错误，其他任何值表明有错误     |

# 字符串操作

```bash
your_name="runoob"
```

### 使用双引号拼接
```bash
greeting="hello, "$your_name"!" 
greeting_1="hello, ${your_name}!" 
echo $greeting $greeting_1
# 输出结果：hello, runoob! hello, runoob!
```

### 使用单引号拼接
```bash
greeting_2='hello, '$your_name'!'
greeting_3='hello, ${your_name}!'
echo $greeting_2 $greeting_3
# 输出结果：hello, runoob! hello, ${your_name}!
```

### **获取字符串长度**
```bash
string="abcd"
echo ${#string}
# 输出：4
```

### **提取子字符串**

这居然是个左闭右闭的区间！

```bash
string="runoob is a great site"
echo ${string:1:4}
# 输出：unoo
```

### **查找子字符**

expr index 是用来查找第一个匹配指定字符集合中任意一个字符的位置，语法为：`expr index STRING CHARS`，返回 STRING 中第一个出现在 CHARS 中的字符的位置（从 1 开始计数），
如果没有找到，则返回 0。

```bash
string="runoob is a great site"
echo $(expr index "$string" io)
# 输出：4
```

# 注释

## 单行注释

使用 `#` 开头为单行注释

## 多行注释

```bash
<<'comment'
    注释内容...
comment
```

或者：

```bash
:<<EOF
    注释内容...
EOF
```

# Shell 数组

### **Bash 数组**

Bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标从 `0` 开始编号。获取数组中的元素需要利用下标，下标可以是整数或算术表达式，其值应大于或等于 `0`。

#### **数组定义**
```bash
array_name=(value0 value1 value2)
```

#### **数组赋值**
```bash
array_name[0]=value0
array_name[1]=value1
```

#### **数组读取**

`@` 获取整个数组。

```bash
${array_name[1]}, ${array_name[@]}
```

#### **数组长度**
```bash
${#array_name[@]}, ${#array_name[n]}
```

# 运算

## 算术运算符

| 运算符 | 说明                     | 举例                          |
|--------|--------------------------|-------------------------------|
| `+`    | 加法                     | `expr $a + $b` 结果为 30。   |
| `-`    | 减法                     | `expr $a - $b` 结果为 -10。  |
| `*`    | 乘法                     | `expr $a \* $b` 结果为 200。 |
| `/`    | 除法                     | `expr $b / $a` 结果为 2。    |
| `%`    | 取余                     | `expr $b % $a` 结果为 0。    |
| `=`    | 赋值                     | `a=$b` 将把变量 `b` 的值赋给 `a`。 |
| `==`   | 相等。用于比较两个数字，相同则返回 `true`。 | `[ $a == $b ]` 返回 `false`。 |
| `!=`   | 不相等。用于比较两个数字，不相同则返回 `true`。 | `[ $a != $b ]` 返回 `true`。 |

## 关系运算符

| 运算符 | 说明                         | 举例                          |
|--------|------------------------------|-------------------------------|
| `-eq`  | 检测两个数是否相等，相等返回 `true`。 | `[ $a -eq $b ]` 返回 `false`。 |
| `-ne`  | 检测两个数是否不相等，不相等返回 `true`。 | `[ $a -ne $b ]` 返回 `true`。  |
| `-gt`  | 检测左边的数是否大于右边的，如果是，则返回 `true`。 | `[ $a -gt $b ]` 返回 `false`。  |
| `-lt`  | 检测左边的数是否小于右边的，如果是，则返回 `true`。 | `[ $a -lt $b ]` 返回 `true`。   |
| `-ge`  | 检测左边的数是否大于等于右边的，如果是，则返回 `true`。 | `[ $a -ge $b ]` 返回 `false`。  |
| `-le`  | 检测左边的数是否小于等于右边的，如果是，则返回 `true`。 | `[ $a -le $b ]` 返回 `true`。   |

## **布尔运算符**

| 运算符 | 说明                      | 举例                            |
|--------|---------------------------|---------------------------------|
| `!`    | 非运算，表达式为 `true` 则返回 `false`，否则返回 `true`。 | `[ ! false ]` 返回 `true`。     |
| `-o`   | 或运算，有一个表达式为 `true` 则返回 `true`。               | `[ $a -lt 20 -o $b -gt 100 ]` 返回 `true`。 |
| `-a`   | 与运算，两个表达式都为 `true` 才返回 `true`。              | `[ $a -lt 20 -a $b -gt 100 ]` 返回 `false`。 |

## **逻辑运算符**

| 运算符 | 说明             | 举例                        |
|--------|------------------|-----------------------------|
| `&&`   | 逻辑的 AND       | `[ [ $a -lt 100 ] && [ $b -gt 100 ] ]` 返回 `false` |
| `||`   | 逻辑的 OR        | `[ [ $a -lt 100 ] || [ $b -gt 100 ] ]` 返回 `true`  |

## 字符串运算符

| 运算符 | 说明                           | 举例                          |
|--------|--------------------------------|-------------------------------|
| `=`    | 检测两个字符串是否相等，相等返回 `true`。 | `[ $a = $b ]` 返回 `false`。 |
| `!=`   | 检测两个字符串是否不相等，不相等返回 `true`。 | `[ $a != $b ]` 返回 `true`。 |
| `-z`   | 检测字符串长度是否为 0，为 0 返回 `true`。 | `[ -z $a ]` 返回 `false`。   |
| `-n`   | 检测字符串长度是否不为 0，不为 0 返回 `true`。 | `[ -n "$a" ]` 返回 `true`。  |
| `$`    | 检测字符串是否为空，不为空返回 `true`。     | `[ $a ]` 返回 `true`。       |

## 文件属性检测运算符

| 运算符      | 说明                                       | 举例                   |
|-------------|------------------------------------------|------------------------|
| `-d file`   | 检测文件是否是目录，如果是，则返回 `true`。 | `[ -d $file ]` 返回 `false`。 |
| `-f file`   | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 `true`。 | `[ -f $file ]` 返回 `true`。 |
| `-r file`   | 检测文件是否可读，如果是，则返回 `true`。   | `[ -r $file ]` 返回 `true`。 |
| `-w file`   | 检测文件是否可写，如果是，则返回 `true`。   | `[ -w $file ]` 返回 `true`。 |
| `-x file`   | 检测文件是否可执行，如果是，则返回 `true`。 | `[ -x $file ]` 返回 `true`。 |
| `-s file`   | 检测文件是否为空（文件大小是否大于 0），不为空返回 `true`。 | `[ -s $file ]` 返回 `true`。 |
| `-e file`   | 检测文件（包括目录）是否存在，如果是，则返回 `true`。 | `[ -e $file ]` 返回 `true`。 |

# 分支

## if

```bash
if condition
then
    cmd1
    cmd2
elif
then
    cmd3
else
    cmd4
fi
```

## case

```bash
case 值 in
模式1)
    cmd1
    ...
    ;;
模式2)
    cmd2
    ...
    ;;
esac
```

## for

```bash
for var in item1 item2 ...
do
    cmd...
done
```

## while

```bash
while condition
do
    cmd...
done
```

或者

```bash
while condition; do
    cmd...
done
```

# Shell 函数

函数格式

```bash
函数名() {
    cmd1
    ...
}
```

| 参数 | 说明                                                             |
| ---- | ---------------------------------------------------------------- |
| `$#` | 传递到脚本或函数的参数个数                                       |
| `$*` | 以一个单字符串显示所有向脚本传递的参数                           |
| `$$` | 脚本运行的当前进程 ID 号                                         |
| `$!` | 后台运行的最后一个进程的 ID 号                                   |
| `$-` | 显示 Shell 使用的当前选项，与 `set` 命令功能相同。               |
| `$?` | 显示最后命令的退出状态。`0` 表示没有错误，其他任何值表明有错误。 |

还有一些类似 `$1`-`$9` 表示第几个传入函数的变量。

# Shell 重定向

| 命令              | 说明                                                   |
| ----------------- | ------------------------------------------------------ |
| `command > file`  | 将输出重定向到 `file`。                                |
| `command < file`  | 将输入重定向到 `file`。                                |
| `command >> file` | 将输出以追加的方式重定向到 `file`。                    |
| `n > file`        | 将文件描述符为 `n` 的文件重定向到 `file`。             |
| `n >> file`       | 将文件描述符为 `n` 的文件以追加的方式重定向到 `file`。 |
| `n >& m`          | 将输出文件 `m` 和 `n` 合并。                           |
| `n <& m`          | 将输入文件 `m` 和 `n` 合并。                           |

**文件描述符**

可以查看到进程号后，到运行中进程的 `/proc/进程号/fd` 文件夹下，查看 `0,1,2` 分别指向了哪一个文件。

| 文件描述符 | 说明                  |
| ---------- | --------------------- |
| `0`        | 标准输入 (stdin)      |
| `1`        | 标准输出 (stdout)     |
| `2`        | 标准错误输出 (stderr) |

一般而言，默认是将标准输出和标准错误输出打印到屏幕，而 `>`, `>>` 修改的是标准输出（`1`）而不会修改 stderr，因此 stderr 仍然会打印到屏幕上。

因此，比如 `2>&1` 表示把标准错误输出重定向到标准输出里去。

# Shell 外部文件

```bash
. filename
或
source filename
```
