---
layout: post
title: Effective C++ 读书笔记
categories: [C++]
description: Effective C++ 读书笔记
keywords: C++, Effective C++, 读书笔记
---

写在前面：在读书笔记中，记录一些书中没有学习过的内容。方便以后不翻书直接看笔记，因此可能会少一些我之前就会的内容。

# 条款 01：视 C++ 为一个语言联邦

- C
- 面向对象
- 模板
- STL

这是当年（1998）年时候的认识，当然以我现在的认识而言，也没有变化多少，仍需继续学习。

# 条款 02：尽量以 const, enum, inline 替换 #define

## 替换宏常量

常量替换 #define 有两种特殊情况：

1. 常量指针可能需要写 `const` 两次，一次 `const` 给指针，另一次 `const` 给指向的内容。另外请记住 `const` 是先修饰左后修饰右的修饰顺序。
2. class 专属常量。
    1. 为确保常量作用域在类内，因此让它成为类的一个成员
    2. 为确保此常量至多只有一份实体，于是让它成为一个 static 成员
    3. 如果是一个类的专属常量、static、整型（int, char, bool）那么可以如下定义，在交叉编译时不会出现错误：

```cpp
class GamePlayer {
private:
    static const int NumTurns = 5;
    int scores[NumTurns];
};
```
但是如果是其他类型（如 double、非 static 等），则无法如此定义。后续如果要取某个类专属常量的地址，那么则必须在实现（.cpp）文件中提供不给予数值的定义式：`const int GamePlayer::NumTurns;`

但假如编译器不支持上面的写法，也可以使用 enum：`enum { NumTurns = 5 };`。

## 替换宏函数

用 template 模板来替换宏函数。至于书中的 inline 来修饰函数，现在近乎是由编译器自主决定，因此写不写差别不大。

# 条款 03：尽可能使用 const

STL 中的 `const_iterator` 可使指向内容无法被改变。

## 令函数返回 const

> 令函数返回 const 好处如下：
> ```cpp
> class Rational {...};
> const Rational operator* (const Rational& lhs, const Rational& rhs);
> 
> Rational a, b, c;
> if (a * b = c) // 这里显然有问题
> ```
> 代码最后一行显然有问题，如果返回 const 可以避免这种比较！

在现代 C++ 中，应当设计明确的接口（返回值、智能指针或 const 引用）来控制对象的可修改性，以此来替代返回 `const`。不过运算符重载仍建议返回 const，不过缺点在于后面初始化别的变量无法移动语义，只能拷贝构造。

## 常量成员函数

常量成员函数表示该函数不会修改调用对象的非静态数据成员。

> 两个成员函数如果只是常量性不同，可以被重载。
> 因此有如下代码，分别重载了常量和变量形式的 `[]`。
> ```cpp
> class TextBlock {
> public:
>     ...
>     const char& operator[](std::size_t position) const 
>     { return text[position]; }
>     char& operator[](std::size_t position) 
>     { return text[position]; }
> private:
>     std::string text;
> };
> ```

如果希望某些成员变量在常量成员函数中也能发生变化，那么请使用 `mutable` 来修饰该成员变量。

## 在 const 和 non-const 成员函数中避免重复

现在面临这样一个问题，如果上面的代码中，两个 `[]` 运算符要执行的内容都很长而且重复内容很多怎么办？

可以**运用 const 成员函数来实现出其 non-const 孪生兄弟**。比如上面的非常量成员函数可以利用**常量性转除**做到下面的事情：

```cpp
char& operator[](std::size_t position) {
    return const_cast<char&>(
        static_cast<const TextBlock&>(*this)[position];
    )
}
```

与此同时，反向做法**令 const 版本调用 non-const 版本**，请不要这么做！

# 条款 04：确定对象被使用前已先被初始化

如果在构造函数中挨个给成员变量赋值，这样不够快，因为初始化的发生于这些成员的构造函数被自动调用之时（比进入类构造函数本体的发生时间更早），因此使用成员初始化列表（member initialization list）替换赋值动作。

```cpp
A::A(std::string name):name(name) {}
```

> 书中建议：请规定总是在初始化列表中列出所有成员变量，以免还得记住哪些成员变量可以无需初值。
>
> 为避免需要记住成员变量何时必须在初始化列表中初始化，什么时候不需要，最简单的做法是：总是使用初始化列表。
>
> 如果类**有多个构造函数**，又不想疯狂地**重复初始化列表**，那么可以在初始化列表中**遗漏那些“赋值表现像初始化一样好”的成员变量**，改用它们的**赋值**操作，并将那些操作移往某个函数（通常是 private），供所有构造函数调用。

C++ 中的成员变量初始化次序是以其**声明次序**被初始化的。在初始化列表中，最好也以**声明次序**为次序。

## 不同编译单元内定义 non-local static 对象的初始化次序

还有一个新问题：**不同编译单元内定义 non-local static 对象的初始化次序**是怎样的？（non-local 指的是非函数内部）

假设 A 和 B 都是 non-local 静态对象，但是 B 初始化中需要调用 A，此时就产生了问题，A 初始化了吗？

可使用单例模式中比较常见的一种实现手法解决它：把这个对象搬到一个专属函数内（声明一个 static），然后返回一个引用指向这个 static 对象。如：

```cpp
class FileSystem { ... };
FileSystem& tfs () {
    static FileSystem fs;
    return fs;
}
class Directory { ... };
Directory::Directory ( params ) {
    ...
    std::size_t disks = tfs().numDisks();
    ...
}
Directory& tempDir() {
    static Directory td;
    return td;
}
```

上面是书中的代码。这里代码建立在构造函数是 public 权限的基础上。

## 单例模式（Singleton）

如果要写**单例模式**的话，请把构造函数权限改为 private，并在成员函数 getInstance 前加上 static，代码如下：

```cpp
class Singleton {
private:
    Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    static Singleton& getInstance() {
        static Singleton instance;  // 静态局部变量
        return instance;
    }
};

// 调用
Singleton a = Singleton::getInstance();
```

C++11 及以后的版本中，保证了静态局部变量的初始化是线程安全的。因此书中的担忧已是过去式。

我有一个疑惑，**为什么单例模式必须用 static 的成员函数**？原因在于，只有 static 的成员函数才能在不定义对象的前提下调用该成员函数。如果单例类 `getInstance()` 函数不加 static，那么私有权限的构造函数会导致无法定义对象。