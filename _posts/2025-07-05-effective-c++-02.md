---
layout: post
title: Effective C++ 读书笔记
categories: [C++]
description: Effective C++ 读书笔记
keywords: C++, Effective C++, 读书笔记
---

# 第四章：设计与声明

## 条款 18：让接口容易被正确使用，不易被误用

> 防范“不值得拥有的代码”上，可以导入简单的外覆类型来防止错误；同时限制类型内什么事可做，什么事不能做。
>
> 除非有好理由，否则应尽量令 types 的行为与内置 types 一致。

`shared_ptr` 有一个性质是会自动使用它“每个指针专属的删除器”，这样可以消除潜在的错误：跨 DLL new delete 成对运用会导致运行期错误。

它的**删除器**可以提前指定，因此可以先让它指向 `null`，如：`std::shared_ptr<Investment> pInv(static_cast<Investment*>(0), InvDeleter);` 或者 `std::shared_ptr<Investment> pInv(nullptr, InvDeleter);`

## 条款 19：设计 class 犹如设计 type

在设计类之前请回答以下问题：

1. 新 type 的对象应该如何被创建和销毁？
2. 对象的初始化和对象的赋值该有什么差别？
3. 新 type 的对象如果被值传递，意味着什么？
4. 什么是新 type 的合法值？
5. 你的新 type 需要配合某个继承图系吗？
6. 你的新 type 需要什么样的转换？
7. 什么样的操作符和函数对此新 type 而言是合理的？
8. 什么样的标准函数应该驳回？
9. 谁该取用新 type 的成员？
10. 什么是新 type 的未声明接口？
11. 你的新 type 有多么一般化？还是需要 template？
12. 你真的需要新 type 吗？

## 条款 20：宁以常量引用传递替换值传递

尽量用常量引用传递替换值传递。前者通常比较高效，并可以避免对象切割问题。

但是与此同时，以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对他们而言，值传递往往会快一点。

## 条款 21：必须返回对象时，别妄想返回其引用

> 绝不要返回指针或引用指向一个局部栈对象，或返回引用指向一个堆分配的对象，或返回指针或引用指向一个局部静态对象而有可能同时需要多个这样的对象。

## 条款 22：将成员变量声明为 private

使用 private 的理由如下：

1. 如果 public 接口内每样东西都是函数，客户不需要在打算访问类成员时迷惑地试着记住是否该使用**小括号**
2. 使用函数可以让你对成员变量的处理有更精确的控制
3. 对客户隐藏成员变量，可以确保类的约束条件总是会获得维护，因为只有成员变量可以影响它们。
4. protected 成员变量其实就像 public 成员变量一样缺乏封装性

综上所述，其实只有两种访问权限：private（提供封装）和其他（不提供封装）。

## 条款 23：宁以非成员非友元替换成员函数

宁可拿非成员非友元函数替换成员函数。这样做可以增加封装性、包裹弹性和机能扩充性。

书中举的例子是让这类函数位于类的同一个命名空间，如果各个函数有不同的用途可以分成不同的头文件然后放入相同的命名空间。

## 条款 24：若所有参数皆需类型转换，请为此采用非成员函数

如果需要为某个函数的所有参数（包括被 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个非成员函数。

成员函数的反面是非成员函数，而不是友元函数。不能够只因函数不该成为成员函数，就自动让它成为友元函数。

## 条款 25：考虑写出一个不抛异常的 swap 函数

如果我们想为 `std::swap` 增加某个类的特化功能，比如类内是个指针，且每次复制 Widget 都会复制其中的对象，代码如下：

```cpp
class Widget {
public:
    ...
    Widget(const Widget& rhs);
    Widget& operator=(const Widget& rhs) {
        ...
        *pImpl = *(rhs.pImpl);
        ...
    }
    void swap(Widget& other) {
        using std::swap;
        swap(pImpl, other.pImpl);
    }
private:
    WidgetImpl* pImpl;
};

namespace std {
    template<> // 模板全特化
    void swap<Widget>(Widget& a, Widget& b) {
        a.swap(b);
    }
}
```

但是如果 `Widget` 和 `WidgetImpl` 都是模板类而不是类，那么特化 `std::swap` 会因为无法偏特化函数而失败。那么应该怎么做呢？

```cpp
namespace WidgetStuff {
    ...
    template<typename T> class Widget {...};
    ...
    template<typename T> void swap(Widget<T>& a, Widget<T>& b) {
        a.swap(b);
    }
}

template<typename T>
void doSomething(T& obj1, T& obj2) {
    using std::swap;
    ...
    swap(obj1, obj2); // 如果 T 是命名空间 WidgetStuff 中的 Widget，那么会直接寻找调用 WidgetStuff 中的 swap，如果没有，再去 std 中寻找。
    ...
}
```

1. 提供一个 public swap 函数，让它高效置换。需要注意，这个函数**绝不该抛出异常**。
2. 比较普遍的做法是：在 class 或 template 所在命名空间提供一个非成员 swap，并令它调用上述 swap 成员函数。
3. 如果正编写一个 class 而非模板类，为 class 特化 `std::swap`。并令它调用你的 swap 成员函数。
4. 最后，调用 `swap` 时，请确定包含一个 using 声明式，以便让 `std::swap` 在函数内曝光可见，然后不加任何 namespace 修饰符，直接调用 `swap`。
   
最后，成员版 `swap` 绝不可抛出异常，原因是：`swap` 的一个最好的应用是帮助类提供强烈的异常安全性保障（详见条款 29）。非成员版 `swap` 则没有这个限制。

# 第五章：实现

## 条款 26：尽可能延后变量定义式的出现时间

> 你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参位置。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的 default 构造行为。

但是循环怎么办呢？下面代码是 A 好还是 B 好？

```cpp
// A
Widget w;
for (int i = 0; i < n; i++) {
    w = xxxx;
    ...
}

// B
for (int i = 0; i < n; i++) {
    Widget w(xxxx);
    ...
}
```

A 会导致 w 的作用域显著比 B 更大。这里除非你明确知道赋值成本比“析构+构造”成本低，而且正在疯狂卡常，否则请尽可能使用做法 B。

## 条款 27：尽量少做转型动作

大致有三种转型：

1. C 风格转型 `(T)expression`
2. 函数风格转型 `T(expression)`
3. C++ 新型转型
   1. `const_cast<T>(expression)`
   2. `dynamic_cast<T>(expression)`
   3. `reinterpret_cast<T>(expression)`
   4. `static_cast<T>(expression)`
   
> 作者唯一使用旧式转型的时机是，当他要调用一个 explicit 构造函数将一个对象传递给一个函数时。请始终理智地**使用新型转型**。

派生类想调用基类同名函数时，请不要给 `*this` 转型然后调用函数，因为这样会调用到副本上去，请这么写：

```cpp
class SpecialWindow: public Window {
public:
    virtual void onResize() {
        Window::onResize(); // 这样调用
    }
}
```

`Dynamic_cast` 的许多实现版本非常之慢。之所以需要它，是因为想要在一个认定为派生类对象上执行派生类的操作函数，但是此时却中只有指向基类的指针或者引用。有两个方法可以解决问题：

1. 使用容器并在其中存储直接指向派生类对象的指针。
2. 基类中提供虚函数。

此外，**必须避免一连串的 `dynamic_cast`**。这样产生的代码又大又慢，而且一旦类继承体系有改变，那么所有这一类代码都必须看看是否需要修改。请使用“基于虚函数调用”的东西取代它们。这种代码如下所示：

```cpp
Window* iter;
if (SpecialWindow1* psw1 = dynamic_cast<SpecialWindow1*>(iter)) { ... }
else if (SpecialWindow2* psw2 = dynamic_cast<SpecialWindow2*>(iter)) { ... }
...
```

请尽可能隔离转型动作，通常是把它隐藏在某个函数内，函数的接口可以保护调用者不受函数内部动作影响。

## 条款 28：避免返回 handles 指向对象内部成分

成员变量的封装性最多值等于“返回其引用”的函数的访问级别。如果 const 成员函数传出一个引用，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。

引用、指针和迭代器都是 handles。返回一个“代表对象内部数据”的 handle，随之而来的是“降低对象封装性”的风险。

除此之外可能导致其他问题，比如 handle 生命周期比对象长导致了空 handle 问题。

不过，也有一些 STL 容器中的 `operator[]` 就返回了容器内数据的引用，这是例外。

