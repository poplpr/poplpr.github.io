---
layout: post
title: Effective C++ 读书笔记
categories: [C++]
description: Effective C++ 读书笔记
keywords: C++, Effective C++, 读书笔记
---

# 第四章：设计与声明

## 条款 18：让接口容易被正确使用，不易被误用

> 防范“不值得拥有的代码”上，可以导入简单的外覆类型来防止错误；同时限制类型内什么事可做，什么事不能做。
>
> 除非有好理由，否则应尽量令 types 的行为与内置 types 一致。

`shared_ptr` 有一个性质是会自动使用它“每个指针专属的删除器”，这样可以消除潜在的错误：跨 DLL new delete 成对运用会导致运行期错误。

它的**删除器**可以提前指定，因此可以先让它指向 `null`，如：`std::shared_ptr<Investment> pInv(static_cast<Investment*>(0), InvDeleter);` 或者 `std::shared_ptr<Investment> pInv(nullptr, InvDeleter);`

## 条款 19：设计 class 犹如设计 type

在设计类之前请回答以下问题：

1. 新 type 的对象应该如何被创建和销毁？
2. 对象的初始化和对象的赋值该有什么差别？
3. 新 type 的对象如果被值传递，意味着什么？
4. 什么是新 type 的合法值？
5. 你的新 type 需要配合某个继承图系吗？
6. 你的新 type 需要什么样的转换？
7. 什么样的操作符和函数对此新 type 而言是合理的？
8. 什么样的标准函数应该驳回？
9. 谁该取用新 type 的成员？
10. 什么是新 type 的未声明接口？
11. 你的新 type 有多么一般化？还是需要 template？
12. 你真的需要新 type 吗？

## 条款 20：宁以常量引用传递替换值传递

尽量用常量引用传递替换值传递。前者通常比较高效，并可以避免对象切割问题。

但是与此同时，以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对他们而言，值传递往往会快一点。

## 条款 21：必须返回对象时，别妄想返回其引用

> 绝不要返回指针或引用指向一个局部栈对象，或返回引用指向一个堆分配的对象，或返回指针或引用指向一个局部静态对象而有可能同时需要多个这样的对象。

## 条款 22：将成员变量声明为 private

使用 private 的理由如下：

1. 如果 public 接口内每样东西都是函数，客户不需要在打算访问类成员时迷惑地试着记住是否该使用**小括号**
2. 使用函数可以让你对成员变量的处理有更精确的控制
3. 对客户隐藏成员变量，可以确保类的约束条件总是会获得维护，因为只有成员变量可以影响它们。
4. protected 成员变量其实就像 public 成员变量一样缺乏封装性

综上所述，其实只有两种访问权限：private（提供封装）和其他（不提供封装）。

## 条款 23：宁以非成员非友元替换成员函数

宁可拿非成员非友元函数替换成员函数。这样做可以增加封装性、包裹弹性和机能扩充性。

书中举的例子是让这类函数位于类的同一个命名空间，如果各个函数有不同的用途可以分成不同的头文件然后放入相同的命名空间。

## 条款 24：若所有参数皆需类型转换，请为此采用非成员函数

如果需要为某个函数的所有参数（包括被 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个非成员函数。

成员函数的反面是非成员函数，而不是友元函数。不能够只因函数不该成为成员函数，就自动让它成为友元函数。

## 条款 25：考虑写出一个不抛异常的 swap 函数

如果我们想为 `std::swap` 增加某个类的特化功能，比如类内是个指针，且每次复制 Widget 都会复制其中的对象，代码如下：

```cpp
class Widget {
public:
    ...
    Widget(const Widget& rhs);
    Widget& operator=(const Widget& rhs) {
        ...
        *pImpl = *(rhs.pImpl);
        ...
    }
    void swap(Widget& other) {
        using std::swap;
        swap(pImpl, other.pImpl);
    }
private:
    WidgetImpl* pImpl;
};

namespace std {
    template<> // 模板全特化
    void swap<Widget>(Widget& a, Widget& b) {
        a.swap(b);
    }
}
```

但是如果 `Widget` 和 `WidgetImpl` 都是模板类而不是类，那么特化 `std::swap` 会因为无法偏特化函数而失败。那么应该怎么做呢？

```cpp
namespace WidgetStuff {
    ...
    template<typename T> class Widget {...};
    ...
    template<typename T> void swap(Widget<T>& a, Widget<T>& b) {
        a.swap(b);
    }
}

template<typename T>
void doSomething(T& obj1, T& obj2) {
    using std::swap;
    ...
    swap(obj1, obj2); // 如果 T 是命名空间 WidgetStuff 中的 Widget，那么会直接寻找调用 WidgetStuff 中的 swap，如果没有，再去 std 中寻找。
    ...
}
```

1. 提供一个 public swap 函数，让它高效置换。需要注意，这个函数**绝不该抛出异常**。
2. 比较普遍的做法是：在 class 或 template 所在命名空间提供一个非成员 swap，并令它调用上述 swap 成员函数。
3. 如果正编写一个 class 而非模板类，为 class 特化 `std::swap`。并令它调用你的 swap 成员函数。
4. 最后，调用 `swap` 时，请确定包含一个 using 声明式，以便让 `std::swap` 在函数内曝光可见，然后不加任何 namespace 修饰符，直接调用 `swap`。
   
最后，成员版 `swap` 绝不可抛出异常，原因是：`swap` 的一个最好的应用是帮助类提供强烈的异常安全性保障（详见条款 29）。非成员版 `swap` 则没有这个限制。

# 第五章：实现

## 条款 26：尽可能延后变量定义式的出现时间

> 你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参位置。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的 default 构造行为。

但是循环怎么办呢？下面代码是 A 好还是 B 好？

```cpp
// A
Widget w;
for (int i = 0; i < n; i++) {
    w = xxxx;
    ...
}

// B
for (int i = 0; i < n; i++) {
    Widget w(xxxx);
    ...
}
```

A 会导致 w 的作用域显著比 B 更大。这里除非你明确知道赋值成本比“析构+构造”成本低，而且正在疯狂卡常，否则请尽可能使用做法 B。

## 条款 27：尽量少做转型动作

大致有三种转型：

1. C 风格转型 `(T)expression`
2. 函数风格转型 `T(expression)`
3. C++ 新型转型
   1. `const_cast<T>(expression)`
   2. `dynamic_cast<T>(expression)`
   3. `reinterpret_cast<T>(expression)`
   4. `static_cast<T>(expression)`
   
> 作者唯一使用旧式转型的时机是，当他要调用一个 explicit 构造函数将一个对象传递给一个函数时。请始终理智地**使用新型转型**。

派生类想调用基类同名函数时，请不要给 `*this` 转型然后调用函数，因为这样会调用到副本上去，请这么写：

```cpp
class SpecialWindow: public Window {
public:
    virtual void onResize() {
        Window::onResize(); // 这样调用
    }
}
```

`Dynamic_cast` 的许多实现版本非常之慢。之所以需要它，是因为想要在一个认定为派生类对象上执行派生类的操作函数，但是此时却中只有指向基类的指针或者引用。有两个方法可以解决问题：

1. 使用容器并在其中存储直接指向派生类对象的指针。
2. 基类中提供虚函数。

此外，**必须避免一连串的 `dynamic_cast`**。这样产生的代码又大又慢，而且一旦类继承体系有改变，那么所有这一类代码都必须看看是否需要修改。请使用“基于虚函数调用”的东西取代它们。这种代码如下所示：

```cpp
Window* iter;
if (SpecialWindow1* psw1 = dynamic_cast<SpecialWindow1*>(iter)) { ... }
else if (SpecialWindow2* psw2 = dynamic_cast<SpecialWindow2*>(iter)) { ... }
...
```

请尽可能隔离转型动作，通常是把它隐藏在某个函数内，函数的接口可以保护调用者不受函数内部动作影响。

## 条款 28：避免返回 handles 指向对象内部成分

成员变量的封装性最多值等于“返回其引用”的函数的访问级别。如果 const 成员函数传出一个引用，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。

引用、指针和迭代器都是 handles。返回一个“代表对象内部数据”的 handle，随之而来的是“降低对象封装性”的风险。

除此之外可能导致其他问题，比如 handle 生命周期比对象长导致了空 handle 问题。

不过，也有一些 STL 容器中的 `operator[]` 就返回了容器内数据的引用，这是例外。

## 条款 29：为“异常安全”而努力是值得的

当异常被抛出时，具有异常安全性的函数会：

1. 不泄露任何资源
2. 不允许数据败坏

异常安全函数提供以下三个保证之一：

1. **基本承诺**：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。然而程序的现实状态恐怕不可预料
2. **强烈保证**：如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。
3. **不抛掷（nothrow）保证**：承诺绝不抛异常，因为它们总是能够完成它们原先承诺的功能。

异常安全的代码必须提供上述三种保证之一。

copy and swap 策略会很典型地导致强烈保证。实际上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象。然后做一个副本，所有操作在副本上进行。改变完成后，再将修改过的副本和原对象在一个不抛出异常的操作中置换。

虽然很好，但是一般而言它并不保证整个函数有强烈的异常安全性。原因在于函数内部还会调用许多函数，内部函数的连带影响使得很难回复到本函数调用之前。强烈保证并非在任何时刻都显得实际。

## 条款 30：透彻了解 inline 的里里外外

由于内联替换在标准语义中是不可观察的，因此编译器可以自由地对任何未标记为 inline 的函数使用内联替换，并且可以自由地为任何标记为 inline 的函数生成函数调用。

在开 O2 的状态下，编译器会忽略所有 inline，并自主判定是否使用。

## 条款 31：将文件间的编译依存关系降至最低

尝试将接口与实现分离，分离的关键在于以声明的依存性替换定义的依存性，正是编译依存最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。

1. 如果使用对象引用或对象指针可以完成任务，就不要使用对象
2. 如果能够，尽量以类声明式替换类定义式
3. 为声明式和定义式提供不同的头文件

有两种方式能比较好地将实现和定义类分离：

1. handle 类：类中只包含一个指针成员，指向其实现类，这种设计一般称为 pimpl idiom
2. 抽象基类：派生类完成操作
   1. 创建对象时通常调用一个工厂函数，创建派生类对象返回基类指针

这两种方式虽然降低文件间地编译依存性，但是会使在运行期间丧失若干速度。

## 条款 32：确定你的 public 继承塑模出 is-a 关系

public 继承意味 is-a（是一种）地关系。即，派生类是 public 基类的一种。如果某函数形参是一个基类，那么传入一个派生类是被允许的行为。

对于设计，请尽可能采用在编译期发现错误，而不是在运行期才发现错误的模式。

## 条款 33：避免遮掩继承而来的名称

public 继承后，派生类的作用域被嵌套在基类作用域内。如果派生类中声明了和基类中相同名称的函数，那么会遮掩掉基类中的函数。不过，也可以 `using 基类::函数名;` 来避免遮掩。

有时候不想继承基类中所有函数，这种情况下只有 private 继承才有意义，此时写一个转交函数中调用 `基类::函数名();` 即可使用基类中函数。

## 条款 34：区分接口继承和实现继承

可以利用纯虚函数、非纯虚函数+实现、非虚函数来精确指定派生类继承的东西：只继承接口、继承接口和一份默认实现、或是继承接口和一个强制实现。

- 成员函数的接口总是会被继承
- 声明一个纯虚函数的目的是为了让派生类只继承函数接口
- 声明带实现的非纯虚函数的目的，是让派生类继承该函数的接口和默认实现
- 声明非虚函数的目的是为了让派生类继承函数的接口和一份强制性实现

有两种错误：

1. 把所有函数声明为非虚函数，这样会导致派生类无法特化。
2. 把所有函数声明为虚函数，但是可能有某些函数就是不该在派生类中被重新定义。

书中写了一种情况：一部分派生类同名成员函数不需要基类的默认实现，那么怎么做呢？基类成员函数声明为纯虚函数并附上实现，派生类成员函数欲使用默认实现的中调用该基类纯虚函数即可。

## 条款 35：考虑虚函数以外的其他选择

除虚函数外，有如下几种常用做法：

1. 使用 non-virtual interface（NVI）手法。这是以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的虚函数（该函数可被派生类重新定义），以实现虚函数访问前与访问后共通的工作。
2. 使用函数指针实现 Strategy 模式。即：
    ```cpp
    class GameCharacter;
    int defaultHealthCalc(const GameCharacter& gc);
    class GameCharacter {
    public:
        // typedef int (*HealthCalcFunc)(const GameCharacter&);
        using HealthCalcFunc = int (*)(const GameCharacter&); // 效果一样
        explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {}
        int healthValue() const { return healthFunc(*this);}
        ...
    private:
        HealthCalcFunc healthFunc;
    }
    ```
    不过，如果需要函数指针使用非 public 信息来计算，就只能弱化类的封装了。
3. 使用 `std::function` 来完成 Strategy 模式。使用这个类型产生的对象可以持有（保存）任何与此签名式兼容的可调用物。包括了：函数、函数对象、成员函数；以及可以隐式转化为返回值的上述函数类型。原文中还使用了 `std::tr1::bind`，现在已经推荐尽可能使用 lambda 函数了。
4. 古典 Strategy 模式。将继承体系内的虚函数替换为另一个继承体系内的虚函数。

## 条款 36：绝不重新定义继承而来的非虚函数

非虚函数是静态绑定的，但是虚函数是动态绑定的。因此假如说有个对象 `x`，其为 `D` 类派生于基类 `B`，都定义了一个非虚函数 `mf()`。分别使用 `D* pD = &x;` 和 `B* pB = &x;` 调用 `pD -> mf();` 和 `pB -> mf();` 会导致调用不同的函数。

因此请不要重新定义继承而来的非虚函数。

## 条款 37：绝不重新定义继承而来的默认参数值

绝不要重新定义继承而来的默认参数值，因为默认参数值都是静态绑定，而虚函数却是动态绑定。C++ 这么设计的用意在于运行期效率。

对象的静态类型是它在程序中被声明时所采用的类型。动态类型则是 new 时的实际类型。

如果一定要修改，却在 virtual 函数上实现屡屡受挫，建议参考条款 35，比如可以使用 NVI 手法，在基类的 public 中指定默认参数值后，调用 private 的派生类虚函数，它完成真正的工作。

## 条款 38：通过复合塑模出 has-a 或“根据某物实现出”

复合（composition）是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系。在应用域，复合意味着 has-a（类中有另一类）；而在实现域，复合意味着根据某物实现出来。

## 条款 39：明智而审慎地使用 private 继承

private 继承不意味着是一种的关系，它意味根据某物实现出的关系。当派生类想要访问 protected 中的成员，或者需要重新定义继承而来的 virtual 函数，这样设计存在合理性。

其最大的合理性在于，如果使用复合的话，包含这个类假如是一个没有任何数据（没有 non-static 成员变量、没有虚函数、没有虚基类），为了 EBO（empty base optimization；空白基类最优化）才这样继承。否则编译器会给包含的无数据类成员分配内存空间，造成空间上的损耗。另外，EBO 一般只在**单一继承**下才可行。

## 条款 40：明智而审慎地使用多重继承

多重继承的一大问题在于：“钻石型多重继承”，即 B、C 继承了 A，而 D 多重继承了 B 和 C，那么这个 A 类是一份还是两份呢？

C++ 默认做法是搞两份出来，但是如果只要一份呢？那就需要采用**virtual 继承**了。代码如下：

```cpp
class A {...};
class B: virtual public A {...};
class C: virtual public A {...};
class D: public B, public C {...};
```

那么 public 继承是否都应该加上 virtual 呢？这样的后果是：

1. 使用 virtual 继承的类产生的对象往往比非虚继承的空间大
2. 无论派生类距离虚基类多远，必须要初始化虚基类

因此，作者的忠告是：

> 第一，非必要不适用虚基类，平常请使用非虚继承。第二，如果必须使用虚基类，尽可能避免在其中放置数据

书中举的一个多重继承的合理例子是：“public 继承某个接口类”和“private 继承某个协助实现的类”两相组合。