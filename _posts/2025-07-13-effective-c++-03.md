---
layout: post
title: Effective C++ 读书笔记
categories: [C++]
description: Effective C++ 读书笔记
keywords: C++, Effective C++, 读书笔记
---

# 第七章 模板与泛型编程

## 条款 41：了解隐式接口和编译期多态

在 template 中，显示接口和运行期多态仍然存在，但重要性降低，反倒是隐式接口和编译期多态移到前头。

“以不同的 template 参数具现化 function template”会导致调用不同的函数，这便是所谓的编译期多态。对 template 参数而言，接口是隐式的，奠基于有效表达式。多态是通过 template 具现化和函数重载解析发生于编译期。

## 条款 42：了解 typename 的双重意义

前面了解过，`template<class T>` 和 `template<typename T>` 等价，但是 typename 仍然有自己的独特用途：

任何时候当你想要在 template 中指涉一个嵌套从属类型名称，就必须在紧邻它的前一个位置放上关键字 `typename`。比如：`typename C::iterator iter`。这样做是为了防止声明一个指针的时候，编译器会把它错误地理解为是一个静态成员变量和后面的内容相乘。

不过，这一规则也有例外，`typename` 不可以出现在继承基类列表的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类修饰符。例如：

```cpp
template<typename T>
class D: public B<T>::Nested { // 这里不允许 typename
public:
    explicit D(int x): B<T>::Nested(x) { // 这里也不允许 typename
        typename B<T>::Nested temp; // 这里请加上 typename
    }
}
```