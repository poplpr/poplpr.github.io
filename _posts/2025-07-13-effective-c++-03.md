---
layout: post
title: Effective C++ 读书笔记
categories: [C++]
description: Effective C++ 读书笔记
keywords: C++, Effective C++, 读书笔记
---

# 第七章 模板与泛型编程

## 条款 41：了解隐式接口和编译期多态

在 template 中，显示接口和运行期多态仍然存在，但重要性降低，反倒是隐式接口和编译期多态移到前头。

“以不同的 template 参数具现化 function template”会导致调用不同的函数，这便是所谓的编译期多态。对 template 参数而言，接口是隐式的，奠基于有效表达式。多态是通过 template 具现化和函数重载解析发生于编译期。

## 条款 42：了解 typename 的双重意义

前面了解过，`template<class T>` 和 `template<typename T>` 等价，但是 typename 仍然有自己的独特用途：

任何时候当你想要在 template 中指涉一个嵌套从属类型名称，就必须在紧邻它的前一个位置放上关键字 `typename`。比如：`typename C::iterator iter`。这样做是为了防止声明一个指针的时候，编译器会把它错误地理解为是一个静态成员变量和后面的内容相乘。

不过，这一规则也有例外，`typename` 不可以出现在继承基类列表的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类修饰符。例如：

```cpp
template<typename T>
class D: public B<T>::Nested { // 这里不允许 typename
public:
    explicit D(int x): B<T>::Nested(x) { // 这里也不允许 typename
        typename B<T>::Nested temp; // 这里请加上 typename
    }
};
```

## 条款 43：学习处理模板化基类内的名称

```cpp
template<typename Company>
class MsgSender {
public:
    ...
    void sendClear(const MsgInfo& info) {
        std::string msg;
        Company c;
        c.sendCleartext(msg);
    }
};

template<typename Company>
class LoggingMsgSender: public MsgSender<Company> {
public:
    ...
    void sendClearMsg(const MsgInfo& info) {
        ...
        sendClear(info); // 这里会发生编译错误
        ...
    }
};
```

C++ 模板采用两阶段编译：
1. 第一阶段（定义阶段）
   1. 解析模板定义，检查非依赖名称（如普通函数、全局变量）。
   2. 忽略依赖名称（如 `Base<T>::f()`），因为此时 `T` 未知。
2. 第二阶段（实例化阶段）
   1. 根据具体类型（如 `T=int`）实例化模板。
   2. 检查依赖名称是否存在，并验证其有效性

这里 `sendClear()` 函数会发生编译错误。原因在于，以模板编译的二阶段编译而言，不知道是否有特化的 `MsgSender` 类中有没有 `sendClear()` 函数。在这里我想到了一个别的问题：编译器能不能直接把检测这个问题函数的过程放到实例化阶段去呢？如果这样的话，编译期的效率其实就有些慢了。假如这个函数真的有问题，那么在定义阶段就能发现明显错误。

解决编译失败的方法有三种：

1. `this->sendClear(info);`
2. `using MsgSender<Company>::sendClear;`
3. `MsgSender<Company>::sendClear(info);`

建议使用第一种，原因在于如果二三调用的是虚函数，上述的明确修饰资格会关闭“虚绑定行为”。

## 条款 44：将与参数无关的代码抽离模板

> 模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生相依关系。
>
> 因非类型模板参数而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换模板参数
>
> 因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述的具现类型（如 `void*`）共享实现码。

书中重点讲了一下非类型模板参数的代码膨胀。比如：

```cpp
template<typename T>
class SquareMatrixBase {
protected:
    ...
    void invert(std::size_t matrixSize);
    ...
};

template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
public:
    ...
    void invert() { this -> invert(n);}
};
```

中间可能会涉及到使用指针什么的存储矩阵数据，然后传递给基类什么的这种问题。这里我懒得敲了。

这样膨胀的代码会缩小很多。

## 条款 45：运用成员函数模板接受所有兼容类型

在本条款中，使用成员函数模板生成“可接受所有兼容类型”的函数。

举个朴素的智能指针的例子:

```cpp
template<typename T>
class SmartPtr {
public:
    SmartPtr(const SmartPtr& other);
    template<typename U>
    SmartPtr(const SmartPtr<U>& other)
      : heldPtr(other.get()) { ... } // 泛化 copy 函数
    T* get() const { return heldPtr;}
    ...
private:
    T* heldPtr;
};
```

上面代码有趣的特点如下：

1. 泛化 copy 函数没有声明为 explicit，这是为了与原始指针可以隐式转型行为一致特意这样做的。
2. 构造函数中，只有“存在某个隐式转换可将一个 U* 指针转换为一个 T* 指针”时才能通过编译。
3. 如果 U 和 T 是一种类型时，假如只写了泛化 copy 函数，那么在调用时，编译器会自动生成 copy 构造函数，赋值操作也同理。因此若要强制定义 copy 构造函数，可以如代码中这样写，赋值操作同理。
4. 此外，代码中没有写的东西，如，unique_ptr 和 shared_ptr 无法隐式转换，但是 shared_ptr 与 shared_ptr 可以隐式转换。

## 条款 46：需要类型转换时请在模板内定义非成员函数

先吐个槽：这怎么把 inside template 翻译成“请为模板”而不是“请在模板内”的？

在 template 实参推导中从不将隐式类型转换函数纳入考虑。在 template 实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。

因此，假如说现有一个有理数模板类 `Rational<T>`，由于上面的问题，**我们应当如何重载一个可以隐式类型转换的 `operator*` 呢？**

为了让类型转换可能发生在所有实参上，我们需要一个非成员函数；为了令这个函数自动具现化，需要将它声明在类内部；而在类内部声明非成员函数唯一方法就是令它成为一个友元。

### C++ 98 版本

在 C++ 98 版本（作者原书的版本）中，无法令类外部的 `operator* template` 提供定义式，因此，定义式不得不与声明合并：

```cpp
// .h
template<typename T> class Rational;
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, 
                             const Rational<T>& rhs);

template<typename T>
class Rational {
public:
    ...
    friend const Rational<T> operator* (const Rational<T>& lhs, const Rational<T>& rhs) {
        return doMultiply(lhs, rhs);
    }
}

// .cpp
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, 
                             const Rational<T>& rhs) {
    ...
}
```

### C++11 版本

但是在 C++11 版本中，引入了类模板中友元函数显式指定模板实参的语法特性，因此得以将该函数的声明和定义式分离：

```cpp
template<typename T>
class Rational;

// 前向声明模板函数
template<typename T>
Rational<T> operator*(const Rational<T>& lhs, const Rational<T>& rhs);

template<typename T>
class Rational {
public:
    // 声明友元函数（引用外部模板）
    friend Rational<T> operator* <T>(const Rational<T>& lhs, const Rational<T>& rhs);
};

// 类外定义
template<typename T>
Rational<T> operator*(const Rational<T>& lhs, const Rational<T>& rhs) {
    return Rational<T>(lhs.numerator * rhs.numerator, 
                      lhs.denominator * rhs.denominator);
}
```

可以看到，在类内声明友元函数时，`operator*` 后多了一个 `<T>`，这个关键的要素请不要忘记。

**如果不写 `<T>` 的话**，类中声明的是一个普通函数（非模板），其参数类型恰好是 `Rational<T>`。于是会实例化出一堆这些声明：

```cpp
// 类中声明的普通函数（每个T生成不同版本）
friend Rational<int> operator*(const Rational<int>&, const Rational<int>&);  // T=int时
friend Rational<double> operator*(const Rational<double>&, const Rational<double>&);  // T=double时
```

而类外定义的 `template<typename T> operator*` 与类中实例化后声明的普通函数完全无关。编译器会认为这是两个不同的函数，导致链接错误。

## 条款 47：请使用 traits class 表现类信息

STL 中共有 5 种迭代器分类：

1. Input 迭代器：只能向前移动，一次一步，只能读取一次。
2. Output 迭代器：只能向前移动，一次一步，只能涂写一次。
3. forward 迭代器：可以做前述两种分类能做的每一件事，而且可以读写一次以上。
4. Bidirectional 迭代器：比上一个更强，可以向前或向后移动。
5. random access 迭代器：可以在常量时间内向前或向后跳跃任意距离。

如果我们想基于不同的迭代器类型，做不同的事情，应该怎么做呢？

> 设计一个 traits class，然后利用这个 trait class 给模板函数信息。这个技术的要求之一是，它对内置类型和用户自定义类型的表现必须一样好。

如何设计 trait class？

- 确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类。
- 为该信息选择一个名称，并在 class 中 `typedef` 如 `typedef random_access_iterator_tag iterator_category` 或者 using 也可以。
- 提供一个 template 和一组特化版本，内含你希望支持的类型相关信息。

如何使用 trait class？

- 建立一组重载函数或函数模板，彼此间差异只在于各自的 traits 参数。令每个函数实现代码与其接受的 traits 信息相和。
- 建立一个控制函数或函数模板，它调用上述那些重载函数并传递 traits class 所提供的信息。

```cpp
template<typename iterT, typename DistT> 
void doAdvance(IterT& iter, DistT d, std::bidrectional_iterator_tag) {
    ...
}
template<typename iterT, typename DistT> 
void doAdvance(IterT& iter, DistT d, std::random_access_iterator_tag) {
    ...
}

template<typename iterT, typename DistT> 
void advance(IterT& iter, DistT d) {
    doAdvance(
        iter, d,
        typename std::iterator_traits<iterT>::iterator_category();
    )
}
```

这是 C++98 的做法，C++11 中使用 `std::conditional` 或者 `std::enable_if`，C++17 中使用 if constexpr，以后再深入研究吧。

## 条款 48：认识 template 元编程

以后再了解吧。

# 第八章 定制 new 和 delete

 