---
layout: post
title: More Effective C++ 读书笔记
categories: [C++]
description: More Effective C++ 读书笔记
keywords: C++, More Effective C++, 读书笔记
---

# 第一章 基础议题

## 条款 01：仔细区别指针与引用

- 什么时候选择使用**引用**？
  - 当确定“总是会代表某个对象”而且“一旦代表了该对象就不能够再改变”
  - 如 `operator[]` 这类操作符
  - 效率会相较指针稍高，因为不需要测试其有效性（是否为 null）
- 什么时候用**指针**？
  - 需要考虑“不指向任何对象”的可能性时
  - 或是考虑“在不同时间指向不同对象”的能力时

## 条款 02：最好使用 C++ 转型操作符

C 风格的转型缺点有二：

1. 几乎允许将任何类型转换为任何其他类型。
2. 难以辨识。

因此 C++ 引入 4 个新型转型操作符：

1. static_cast
    - 基本上拥有和 C 旧式转型相同的威力和意义，以及相同的限制
2. const_cast
    - 最常见的用途是将某个对象的常量性去除
3. dynamic_cast
    - 将指向基类对象的指针或引用，转型为，指向派生类的指针或引用。并得知转型是否成功。
4. reinterpret_cast
    - 不太具有移植性
    - 常用于转换函数指针
    - 它主要用于处理指针、引用和整数之间的转换，不进行任何类型检查或数据重构，直接重新解释二进制位模式。

## 条款 03：绝对不要以多态方式处理数组

假如用多态方式，持有基类数组指针，然后操作派生类数组，那么会由于派生类占用空间过大，导致数组指针计算出现偏差。

## 条款 04：非必要不提供默认构造器

默认构造器的意思是在没有任何外来信息的情况下将对象初始化，如：

```cpp
class A {
  A() {} // 默认构造器
};
```

不提供默认构造器的原因是让对象不会创建**无意义的值**。

缺点有二：

1. 产生数组的时候会遇到问题
2. 不适用于许多基于模板的容器类
3. 虚基类如果缺少默认构造器，操作会很麻烦。

解决数组问题的方法有三：

1. 使用非堆数组，在定义数组时提供必要的自变量
2. 使用“指针数组”而非“对象数组”
3. 但是“指针数组”空间有点大怎么办？方法是先为此数组分配 raw memory，然后使用 placement new 在这块内存上构造类的对象。

# 第二章 操作符

## 条款 05：对定制的“类型转换函数”保持警觉

定制的类型转换函数包括单自变量构造器和隐式类型转换操作符。

这个隐式类型转换操作符大致是关键词 operator 后加上一个类型名称，如下：

```cpp
class Rational {
public:
  ...
  operator double const(); // 将 rational 转换为 double
};
```

但是，作者建议，**最好不要提供任何类型转换函数**。原因在于，在未预期的情况下，此类函数可能会被调用，而其结果可能是不正确、不直观的程序行为，很难调试。

- 对于隐式类型转换，解决方法是以对等的另一个函数取代类型转换操作符。
- 对于单自变量构造器，可以用 `explicit`。
  - 如果不支持 `explicit`，可以嵌套一个代理类（proxy class）来作为构造函数的形参。

## 条款 06：区别 ++/-- 操作符的前置和后置

处理用户定制类型时，应该尽可能使用前置式，因为它更轻便一点。

后置式的实现是以前置式为基础。如此核心内容请维护前置式的版本，后置式会自动调整为一致的行为。

示例代码如下：

```cpp
class UPInt {
public:
  UPInt& operator++();
  const UPInt operator++(int);
  ...
}

// 前置式 ++i
UPInt& UPInt::operator++() {
  *this += 1;
  return *this;
}

// 后置式 i++
const UPInt UPInt::operator++(int) {
  UPInt oldValue = *this;
  ++(*this);
  return oldValue;
}
```

## 条款 07：千万不要重载 `&&`, `||`, `,` 操作符

由于 C 对于真假表达式采取骤死式的评估方式（即前一个表达式出结果可能不会算下一个表达式），因此如果重载了这几个运算符可能会出大问题。

逗号则是因为其行为无法模仿，无法如逗号一样先算左再算右，最后再返回右。

## 条款 08：了解不同意义的 new 和 delete

new operator 不可重载。其过程是：先调用 operator new（这个是可以重载的）分配足够内存，用于放置某类型的对象；第二步调用构造器，为分配的内存中那个对象设定初始值。

在这个过程中，我们只能改变用来容纳对象的那块内存的分配行为（即 operator new）。

## 条款 09：利用析构函数避免泄露资源

请最好遵循 RAII 原则，多用智能指针以及在析构函数内回收资源。

## 条款 10：在构造函数内阻止资源泄露

现假设类内有若干裸指针。如果在构造函数中发生了异常，已经要出内存的裸指针如何回收资源？要知道，析构函数只会在已经构造完成的对象中调用。

于是，在**裸指针**的前提下，不得不在构造函数中写一大堆 `try...catch...` 的形式，而如果是**常量裸指针**，你会发现你不得不在所有裸指针的初始化函数内，写一大堆 `try..catch...` 的内容。

最好的方法，其实还是引入**智能指针**来管理裸指针指向的资源。
